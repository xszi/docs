<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>可视化的JavaScript —— （六）Generators 和 Iterators | 行书子</title>
    <meta name="generator" content="VuePress 1.8.0">
    <link rel="icon" href="/docs/logo.png">
    <meta name="description" content="文档记录">
    
    <link rel="preload" href="/docs/assets/css/0.styles.ec62b53c.css" as="style"><link rel="preload" href="/docs/assets/js/app.a73529cf.js" as="script"><link rel="preload" href="/docs/assets/js/2.d55b7ed5.js" as="script"><link rel="preload" href="/docs/assets/js/25.43bd6a90.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.5d2f46d9.js"><link rel="prefetch" href="/docs/assets/js/11.1ad8d137.js"><link rel="prefetch" href="/docs/assets/js/12.0db641ab.js"><link rel="prefetch" href="/docs/assets/js/13.ca54d79b.js"><link rel="prefetch" href="/docs/assets/js/14.38146abb.js"><link rel="prefetch" href="/docs/assets/js/15.06fcc698.js"><link rel="prefetch" href="/docs/assets/js/16.bf2884e0.js"><link rel="prefetch" href="/docs/assets/js/17.f6ebf6e7.js"><link rel="prefetch" href="/docs/assets/js/18.58c68ed2.js"><link rel="prefetch" href="/docs/assets/js/19.bcccd12c.js"><link rel="prefetch" href="/docs/assets/js/20.7842e092.js"><link rel="prefetch" href="/docs/assets/js/21.18769ae2.js"><link rel="prefetch" href="/docs/assets/js/22.c4830ba2.js"><link rel="prefetch" href="/docs/assets/js/23.9581b7d2.js"><link rel="prefetch" href="/docs/assets/js/24.37895785.js"><link rel="prefetch" href="/docs/assets/js/26.2d09c848.js"><link rel="prefetch" href="/docs/assets/js/27.f48d4043.js"><link rel="prefetch" href="/docs/assets/js/28.9fe938ab.js"><link rel="prefetch" href="/docs/assets/js/29.9db545a8.js"><link rel="prefetch" href="/docs/assets/js/3.7810185e.js"><link rel="prefetch" href="/docs/assets/js/30.0bff5648.js"><link rel="prefetch" href="/docs/assets/js/31.af0a2225.js"><link rel="prefetch" href="/docs/assets/js/32.cd1745a2.js"><link rel="prefetch" href="/docs/assets/js/33.3cefacce.js"><link rel="prefetch" href="/docs/assets/js/34.37d8a377.js"><link rel="prefetch" href="/docs/assets/js/35.925dc186.js"><link rel="prefetch" href="/docs/assets/js/36.aae85628.js"><link rel="prefetch" href="/docs/assets/js/4.77a548c8.js"><link rel="prefetch" href="/docs/assets/js/5.5fd3c55b.js"><link rel="prefetch" href="/docs/assets/js/6.706caab8.js"><link rel="prefetch" href="/docs/assets/js/7.74938af9.js"><link rel="prefetch" href="/docs/assets/js/8.b788e12b.js"><link rel="prefetch" href="/docs/assets/js/9.c179b739.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.ec62b53c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><!----> <span class="site-name">行书子</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/xszi/javascript-algorithms" target="_blank" rel="noopener noreferrer" class="nav-link external">
  前端算法
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://xszi.github.io/docs/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  机器学习
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://xszi.github.io/docs" target="_blank" rel="noopener noreferrer" class="nav-link external">
  感悟杂记
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://www.github.com/xszi" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/xszi/javascript-algorithms" target="_blank" rel="noopener noreferrer" class="nav-link external">
  前端算法
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://xszi.github.io/docs/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  机器学习
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://xszi.github.io/docs" target="_blank" rel="noopener noreferrer" class="nav-link external">
  感悟杂记
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://www.github.com/xszi" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>前端译站</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/translation/category.html" class="sidebar-link">目录预览</a></li><li><a href="/docs/translation/nginx.html" class="sidebar-link">我希望我早点认识Nginx</a></li><li><a href="/docs/translation/callstack.html" class="sidebar-link">通过两个示例来解释递归和和调用堆栈</a></li><li><a href="/docs/translation/docker.html" class="sidebar-link">通过租用办公空间例子来解释Docker容器</a></li><li><a href="/docs/translation/nodeq.html" class="sidebar-link">关于Node.js的20个面试题</a></li><li><a href="/docs/translation/float.html" class="sidebar-link">将元素浮动到底角</a></li><li><a href="/docs/translation/eventloop.html" class="sidebar-link">可视化的JavaScript —— （一）事件循环</a></li><li><a href="/docs/translation/hoisting.html" class="sidebar-link">可视化的JavaScript —— （二）提升</a></li><li><a href="/docs/translation/scope.html" class="sidebar-link">可视化的JavaScript —— （三）作用域（链）</a></li><li><a href="/docs/translation/jsengine.html" class="sidebar-link">可视化的JavaScript —— （四）JS引擎</a></li><li><a href="/docs/translation/prototype.html" class="sidebar-link">可视化的JavaScript —— （五）原型继承</a></li><li><a href="/docs/translation/geniterator.html" aria-current="page" class="active sidebar-link">可视化的JavaScript —— （六）Generators 和 Iterators</a></li><li><a href="/docs/translation/promise.html" class="sidebar-link">可视化的JavaScript —— （七）Promises 和 Async/Await</a></li><li><a href="/docs/translation/stream.html" class="sidebar-link">NodeJS 流的可视化指南</a></li><li><a href="/docs/translation/chrometool.html" class="sidebar-link">使用 Chrome DevTools 高效调试 JavaScript</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>备忘</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/review/memo.html" class="sidebar-link">知识复习</a></li><li><a href="/docs/review/plan.html" class="sidebar-link">计划</a></li><li><a href="/docs/review/trend.html" class="sidebar-link">前端趋势</a></li><li><a href="/docs/review/question.html" class="sidebar-link">前端开发过程遇到的问题 / 建议</a></li><li><a href="/docs/review/html.html" class="sidebar-link">html备忘</a></li><li><a href="/docs/review/css.html" class="sidebar-link">css备忘</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>训练专题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/topic/sourcemap.html" class="sidebar-link">SourceMap</a></li><li><a href="/docs/topic/hmr.html" class="sidebar-link">HMR原理</a></li><li><a href="/docs/topic/algorithms.html" class="sidebar-link">算法</a></li><li><a href="/docs/topic/webpack.html" class="sidebar-link">webpack</a></li><li><a href="/docs/topic/monitor.html" class="sidebar-link">前端监控</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>TypeScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/typescript/intro.html" class="sidebar-link">安装 TypeScript</a></li><li><a href="/docs/typescript/install.html" class="sidebar-link">编写第一个 TypeScript 程序</a></li><li><a href="/docs/typescript/start.html" class="sidebar-link">初识 TypeScript</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="可视化的javascript-六-generators-和-iterators"><a href="#可视化的javascript-六-generators-和-iterators" class="header-anchor">#</a> 可视化的JavaScript —— （六）Generators 和 Iterators</h1> <p>【六】<a href="https://dev.to/lydiahallie/javascript-visualized-generators-and-iterators-e36" target="_blank" rel="noopener noreferrer">JavaScript Visualized: Generators and Iterators<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>ES6 引入了一个很酷的东西，叫做生成器函数🎉。 每当我问人们关于生成器函数的问题时，他们的回答基本上都是：“我见过他们一次，很困惑，然后就再也没有看过它”，“哦，天哪，我读了这么多博客关于生成器函数的帖子，我仍然不明白”，“我明白了，但为什么会有人使用它”🤔 或者也许这只是我一直在与自己进行的对话，因为这就是我过去长时间思考的方式！但他们实际上很酷。</p> <p>那么，什么是生成器函数？我们先来看一个普通的老式函数👵🏼</p> <p><img src="https://user-images.githubusercontent.com/23453305/120796037-dd027e00-c56c-11eb-9ee6-022f0ce74eae.png" alt="image"></p> <p>是的，这绝对没有什么特别之处！这只是一个记录 4 次的普通函数。让我们调用它！</p> <p><img src="https://user-images.githubusercontent.com/23453305/120796320-45e9f600-c56d-11eb-8286-a8111da70090.gif" alt="unsiscmakhlgxl4dcji7"></p> <p>“但是莉迪亚，为什么你浪费了我5秒钟的时间让我看这个普通无聊的函数”，这是个很好的问题。普通函数遵循一种称为“运行到完成”的模型:当我们调用一个函数时，它将始终运行直到完成(好吧，除非某处出现错误)。我们不能随意把函数停在中间的某个地方。</p> <p>现在最酷的部分来了：生成器函数不遵循“运行到完成”模型! 这是否意味着我们可以随机暂停生成器函数的执行吗？嗯,有点这个味道！让我们看看什么是生成器函数以及如何使用它们。</p> <p>我们通过在<strong>function</strong>关键字后面写一个星号*来创建一个生成器函数</p> <p><img src="https://user-images.githubusercontent.com/23453305/120796965-07087000-c56e-11eb-802b-7c7a85484232.png" alt="image"></p> <p>但这并不是我们使用生成器函数必须做的！ 与常规函数相比，生成器函数实际上以完全不同的方式工作：</p> <ul><li><p>调用生成器函数返回一个生成器对象，它是一个迭代器。</p></li> <li><p>我们可以使用生成器函数中的<code>yield</code>关键字“暂停”执行。</p></li></ul> <p>但这到底是什么意思！？</p> <p>我们先看第一个方式：调用生成器函数返回生成器对象。 当我们调用常规函数时，将执行函数正文并最终返回值。 但是，当我们调用生成器函数时，返回生成器对象！ 让我们看看当我们记录返回的值时看起来像什么。</p> <p><img src="https://user-images.githubusercontent.com/23453305/120798235-a24e1500-c56f-11eb-9f8c-07f0e1f40302.gif" alt="lyuivuuepy1hzpok8rc5"></p> <p>现在，我可以听到你内心(或外部)的尖叫，因为这可能看起来有点难以承受。但是不要担心，我们并不需要使用这里记录的任何属性。生成器对象有什么用呢?首先，我们需要后退一小步，回答常规函数和生成器函数之间的第二个区别：我们可以在生成器函数中使用<code>yield</code>关键字来“暂停”执行。使用生成器函数，我们可以编写如下内容(<code>genFunc</code>是<code>generatorFunction</code>的缩写)</p> <p><img src="https://user-images.githubusercontent.com/23453305/120798197-95312600-c56f-11eb-8999-04fcab5640e3.png" alt="image"></p> <p><code>yield</code>关键字在这里做什么？当遇到<code>yield</code>关键字时，生成器的执行将“暂停”。最好的是，下次运行该函数时，它会记住之前暂停的位置，并从那里开始运行！这里发生了什么(不用担心，稍后会有动画演示)</p> <ol><li>第一次运行时，它在第一行“暂停”，并生成字符串值'✨'。</li> <li>第二次运行时，它从之前的<code>yield</code>关键字所在行开始。然后它一直向下运行，直到第二个<code>yield</code>关键字并生成值'💕'。</li> <li>第三次运行时，它从前面的<code>yield</code>关键字行开始。它一直向下运行，直到遇到<code>return</code>关键字，并返回值<code>Done!</code>。</li></ol> <p>但是…如果我们前面看到调用生成器函数返回一个生成器对象，我们如何调用该函数？生成器对象在这里发挥作用了!</p> <p>生成器对象包含一个<code>next</code>方法(在原型链上)。我们将使用这个方法来迭代生成器对象。但是，为了记住它在生成值之后的状态，我们需要将生成器对象赋值给一个变量。我叫它<code>genObj</code>，是<code>generatorObject</code>的缩写。</p> <p><img src="https://user-images.githubusercontent.com/23453305/120798841-85661180-c570-11eb-9dc8-e60e1ada587b.gif" alt="y54clkzwbc9oemzgybh5"></p> <p>没错，和我们之前看到的一样吓人。让我们看看在调用<code>genObj</code>生成器对象上的下一个方法时会发生什么？</p> <p><img src="https://user-images.githubusercontent.com/23453305/120799019-c2ca9f00-c570-11eb-99a6-0c133b9dbabe.gif" alt="ryzc9gpzw4x5f0eqhzad"></p> <p>生成器一直运行，直到遇到第一个<code>yield</code>关键字，该关键字恰好在第一行！它生成了一个包含‘value’属性和'done'属性的对象。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>{ value: ... , done: ... }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>'value'属性等于我们生成的值。‘done’属性是一个布尔值，只有在生成器函数<strong>return</strong>返回一个值(不是yield生成的!)时才被设置为true。</p> <p>我们停止了对生成器的迭代，这让它看起来像是函数刚刚暂停了!这太酷了。让我们再次调用<code>next</code>方法</p> <p><img src="https://user-images.githubusercontent.com/23453305/120799806-c7dc1e00-c571-11eb-9deb-47c1b1279b36.gif" alt="e7hz87c6xtd31qjx19va"></p> <p>首先，我们记录了字符串<code>First log!</code>到控制台。这既不是<code>yield</code>也不是<code>return</code>关键字，所以它会继续。然后，它遇到了值为'💕'的<code>yield</code>关键字。一个对象通过value属性'💕'和done属性获得，done属性的值为false，因为我们还没有从生成器返回。我们快到了!让我们最后一次调用<code>next</code>。</p> <p><img src="https://user-images.githubusercontent.com/23453305/120800719-da0a8c00-c572-11eb-9cd4-88e4a54e64d4.gif" alt="e7hz87c6xtd31qjx19va"></p> <p>我们记录了<code>Second log!</code>到控制台。然后，它遇到了一个<strong>return</strong>关键字，值为“Done!”。返回的对象的<code>value</code>属性为''Done!''。这次我们实际<code>return</code>了，所以done的值被设为true</p> <p>‘'done’'属性实际上是非常重要的。我们只能迭代生成器对象一次。什么? !那么当我们再次调用下一个方法时会发生什么?</p> <p><img src="https://user-images.githubusercontent.com/23453305/120801502-d3304900-c573-11eb-93f8-bbe0a2534820.gif" alt="wooo83by4eh12akmg5wb"></p> <p>它永远返回<code>undefined</code>。如果您想再次迭代它，您只需要创建一个新的生成器对象</p> <p>正如我们刚刚看到的，生成器函数返回一个迭代器（生成器对象）。但是..等等，一个迭代器？这是否意味着我们可以在返回的对象上使用<code>for of</code>循环和扩展运算符？是的！🤩</p> <p>让我们尝试使用<code>[... ]</code>语法将产生的值分布在数组中。</p> <p><img src="https://user-images.githubusercontent.com/23453305/120881738-f6a3d400-c605-11eb-86e4-3935e463f4ec.gif" alt="xgk99j592vbx3qirw5or"></p> <p>或者通过使用<code>for of</code>循环？</p> <p><img src="https://user-images.githubusercontent.com/23453305/120881769-1804c000-c606-11eb-9dd8-9012baa3cfe8.gif" alt="98k242jz3bqorkjhukwl"></p> <p>哎呀，这么多的可能性！</p> <p>但是，是什么使迭代器成为迭代器呢？因为我们还可以对数组、字符串、映射和集合使用<code>for-of</code>循环和扩展语法。这实际上是因为它们实现了迭代器协议：<code>[Symbol.iterator]</code>。 假设我们有以下值（使用非常具有描述性的名称，哈哈💁🏼‍♀️）：</p> <p><img src="https://user-images.githubusercontent.com/23453305/120881808-54d0b700-c606-11eb-9889-259acba3a91c.png" alt="image"></p> <p><code>array</code>，<code>string</code>以及<code>generatorObject</code>都是迭代器！让我们来看看他们的属性<code>[Symbol.iterator]</code>的值。</p> <p><img src="https://user-images.githubusercontent.com/23453305/120881896-f5bf7200-c606-11eb-8cbb-9d59609623ff.gif" alt="a7inxsrvrp8ykg3xw6zu"></p> <p>但是，不可迭代的值的<code>[Symbol.iterator]</code>值是什么？</p> <p><img src="https://user-images.githubusercontent.com/23453305/120882025-b34a6500-c607-11eb-9a60-1dcc8a230bc5.gif" alt="tpuzuy58g8m7grxvqw8x"></p> <p>是的，是不存在。那么..我们可以简单地手动添加属性<code>[Symbol.iterator]</code>，使不可迭代的成为可迭代吗？我们可以！😃</p> <p><code>[Symbol.iterator]</code>必须返回一个迭代器，包含<code>next</code>返回，就像我们以前看到的一个对象：<code>{ value: '...', done: false/true }</code>。</p> <p>为了简单起见（就像懒惰的我喜欢做的那样），我们可以简单地将 <code>[Symbol.iterator]</code> 的值设置为一个生成器函数，因为它默认返回一个迭代器。我们使对象成为可迭代对象，并设为整个对象生成的值：</p> <p><img src="https://user-images.githubusercontent.com/23453305/120882185-8fd3ea00-c608-11eb-9e95-579e9e6b3698.png" alt="image"></p> <p>现在看看当我们在<code>object</code>对象上使用扩展语法或 <code>for-of</code> 循​​环时会发生什么！</p> <p><img src="https://user-images.githubusercontent.com/23453305/120882267-1092e600-c609-11eb-84b0-782bee74f608.gif" alt="pw2qq1tkfbp8zccuecac"></p> <p>也许我们只想获取对象的键。“哦，那很简单，我们只是<code>yield Object.keys(this)</code> 而不是<code>this</code>！</p> <p><img src="https://user-images.githubusercontent.com/23453305/120882294-4768fc00-c609-11eb-89d6-4b186c98f1ae.png" alt="image"></p> <p>嗯，让我们试试看。</p> <p><img src="https://user-images.githubusercontent.com/23453305/120882308-61a2da00-c609-11eb-9116-707d1a9893b9.gif" alt="75kf40lqcqrudzqgkeb7"></p> <p><code>Object.keys(this)</code>是一个数组，所以产生的值是一个数组。然后我们将这个产生的数组扩展到另一个数组中，从而产生一个嵌套数组。我们不想要这个，我们只想生成每个单独的<code>key</code>！</p> <p>我们可以使用<code>yield*</code>关键字从生成器中的迭代器中生成单个值，所以<code>yield</code>是带星号的 ！假设我们有一个生成器函数，它首先生成一个鳄梨，然后我们想要单独生成另一个迭代器（在这种情况下是一个数组）的值。我们可以用<code>yield*</code>关键字来做到这一点。然后我们委托给另一个生成器！</p> <p><img src="https://user-images.githubusercontent.com/23453305/120882475-cad71d00-c60a-11eb-97f7-8cdebac22656.gif" alt="jtyn5s5o3vdhjkbwwyb0"></p> <p>在继续迭代<code>genOb</code>j迭代器之前，委托生成器的每个值都会被产生。</p> <p>这正是我们需要做的，以便单独获取所有对象键！</p> <p><img src="https://user-images.githubusercontent.com/23453305/120882553-2c978700-c60b-11eb-8927-9d36ddf7d59e.gif" alt="btr4ytbb04c44qfs96v2"></p> <p>生成器函数的另一个用途是我们可以（某种程度上）将它们用作观察者函数。生成器可以等待传入的数据，并且只有当该数据被传递时，它才会处理它。一个例子：</p> <p><img src="https://user-images.githubusercontent.com/23453305/120882656-c3644380-c60b-11eb-9464-f69920939f91.png" alt="image"></p> <p>这里的一个很大的不同是：我们不只是像我们在前面的例子中看到的那样<code>yield [value]</code>。相反，我们分配给一个名为<code>second</code>的值，并生成字符串<code>First!</code>。我们将在第一次调用该<code>next</code>方法时获得该值。</p> <p>让我们看看当我们第一次在可迭代对象上调用<code>next</code>方法时会发生什么。</p> <p><img src="https://user-images.githubusercontent.com/23453305/120882942-21ddf180-c60d-11eb-863c-bb5404790ad3.gif" alt="ob5a4yi79it9q2ben137"></p> <p>在第一行遇到了<code>yield</code>，并产生了值<code>First!</code>。那么，变量<code>second</code>的值是多少？</p> <p>这实际上是我们下次调用它时传递给<code>next</code>方法的值！这一次，让我们传递字符串。<code>I like JavaScript</code></p> <p><img src="https://user-images.githubusercontent.com/23453305/120882938-1ab6e380-c60d-11eb-95e9-397a1555e663.gif" alt="l1840pp2k9h9bgpt1geo"></p> <p>重要的是，在这里看到该<code>next</code>方法的第一次调用尚未跟踪任何输入。我们只是通过第一次调用来启动观察者。生成器在继续之前等待我们的输入，并可能处理我们传递给<code>next</code>方法的值。</p> <p>那么你为什么要使用生成器函数呢？</p> <p>生成器的最大优点之一是它们被懒惰地评估。这意味着调用该<code>next</code>方法后返回的值仅在我们明确要求后才计算！普通函数没有这个：所有的值都是为你生成的，以防你将来需要使用它。</p> <p><img src="https://user-images.githubusercontent.com/23453305/120883008-6b2e4100-c60d-11eb-922e-97ab97480f49.gif" alt="7b24mkp7io3gmnn8pzwa"></p> <p>还有其他几个用例，我通常喜欢这样做，以便在迭代大型数据集时有更多的控制权！</p> <p>想象一下，我们有一个读书俱乐部的清单！📚 为了让这个例子简短而不是一大块代码，每个读书俱乐部只有一个成员。一个会员当前正在阅读几本书，在<code>books</code>数组中表示！</p> <p><img src="https://user-images.githubusercontent.com/23453305/120883095-da0b9a00-c60d-11eb-919e-75531c5ef6fe.png" alt="image"></p> <p>现在，我们正在寻找一本 <code>id</code> 为 <code>ey812</code> 的书。为了找到它，我们可能只使用嵌套的 <code>for</code> 循环或<code>forEach</code>帮助器，但这意味着即使在找到我们正在寻找的团队成员之后，我们仍然会遍历数据！</p> <p>生成器的绝妙之处在于，除非我们告诉它，否则它不会继续运行。这意味着我们可以评估每个返回的项目，如果它是我们正在寻找的项目，我们就不会调用<code>next!</code>， 让我们看看它会是什么样子。</p> <p>首先，让我们创建一个生成器来遍历<code>books</code>每个团队成员的数组。我们将团队成员的book数组传递给函数，遍历数组，并产生每本书！</p> <p><img src="https://user-images.githubusercontent.com/23453305/120883252-be54c380-c60e-11eb-8a7e-028d09a4ffd7.png" alt="image"></p> <p>现在我们必须准备一个迭代<code>clubMembers</code>数组的生成器。我们并不真正关心俱乐部成员本身，我们只需要遍历他们的书。在<code>iterateMembers</code>生成器中，让我们委托<code>iterateBooks</code>迭代器来生成他们的书！</p> <p><img src="https://user-images.githubusercontent.com/23453305/120883332-286d6880-c60f-11eb-84d6-5cb3d92df8a4.png" alt="image"></p> <p>差不多好了！最后一步是遍历书友会。就像在前面的例子中一样，我们并不真正关心书友会本身，我们只关心俱乐部成员（尤其是他们的书）。让我们委托<code>iterateClubMembers</code>迭代器并将<code>clubMembers</code>数组传递给它。</p> <p><img src="https://user-images.githubusercontent.com/23453305/120883336-2f947680-c60f-11eb-85e1-9f5526cad0d4.png" alt="image"></p> <p>为了遍历所有这些，我们需要通过将<code>bookClub</code>数组传递给<code>iterateBookClubs</code>生成器来使生成器对象可迭代。对于迭代器，我现在只调用生成器<code>it</code>对象。</p> <p><img src="https://user-images.githubusercontent.com/23453305/120883407-8d28c300-c60f-11eb-8fc3-a8601f20740a.png" alt="image"></p> <p>让我们调用这个<code>next</code>方法，直到我们得到一本带有 <code>id</code>为 <code>ey812</code> 的书。</p> <p><img src="https://user-images.githubusercontent.com/23453305/120883435-bfd2bb80-c60f-11eb-8da2-1899ffe32cf0.gif" alt="72ghm4ev6el3no9esk1l"></p> <p>好的！我们不必遍历所有数据来获得我们正在寻找的书。相反，我们只是按需查找数据！当然，<code>next</code>每次都手动调用方法效率不高……所以我们来做一个函数吧！</p> <p>让我们将传递一个<code>id</code>给函数，它是我们要查找的书的 <code>id</code>。如果<code>value.id</code>是我们正在寻找的 <code>id</code>，那么只需返回整个<code>value</code>（书对象）。否则，如果<code>id</code>不正确，再次调用<code>next</code>！</p> <p><img src="https://user-images.githubusercontent.com/23453305/120883523-45566b80-c610-11eb-824a-1794e2a89a9c.png" alt="image"></p> <p><img src="https://user-images.githubusercontent.com/23453305/120883553-6919b180-c610-11eb-8a78-404406e55b76.gif" alt="x1zh0ygt5yfq5vb2f5at"></p> <p>当然，这是一个很小的数据集。但是想象一下，我们有大量的数据，或者我们需要解析传入流而仅查找一个值。通常，我们必须等待整个数据集准备就绪，才能开始解析。使用生成器函数，我们可以简单地要求小块数据，检查这些数据，并且只有在我们调用该<code>next</code>方法时才会生成值！</p> <p>【完】</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">1/8/2023, 9:08:35 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/docs/translation/prototype.html" class="prev">
        可视化的JavaScript —— （五）原型继承
      </a></span> <span class="next"><a href="/docs/translation/promise.html">
        可视化的JavaScript —— （七）Promises 和 Async/Await
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/docs/assets/js/app.a73529cf.js" defer></script><script src="/docs/assets/js/2.d55b7ed5.js" defer></script><script src="/docs/assets/js/25.43bd6a90.js" defer></script>
  </body>
</html>
