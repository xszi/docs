<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>可视化的JavaScript —— （七）Promises 和 Async/Await | 行书子</title>
    <meta name="generator" content="VuePress 1.8.0">
    <link rel="icon" href="/docs/logo.png">
    <meta name="description" content="文档记录">
    
    <link rel="preload" href="/docs/assets/css/0.styles.ec62b53c.css" as="style"><link rel="preload" href="/docs/assets/js/app.3f2b36f9.js" as="script"><link rel="preload" href="/docs/assets/js/2.d55b7ed5.js" as="script"><link rel="preload" href="/docs/assets/js/30.0bff5648.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.5f740ad3.js"><link rel="prefetch" href="/docs/assets/js/11.f54b3368.js"><link rel="prefetch" href="/docs/assets/js/12.0db641ab.js"><link rel="prefetch" href="/docs/assets/js/13.ca54d79b.js"><link rel="prefetch" href="/docs/assets/js/14.38146abb.js"><link rel="prefetch" href="/docs/assets/js/15.06fcc698.js"><link rel="prefetch" href="/docs/assets/js/16.bf2884e0.js"><link rel="prefetch" href="/docs/assets/js/17.f6ebf6e7.js"><link rel="prefetch" href="/docs/assets/js/18.58c68ed2.js"><link rel="prefetch" href="/docs/assets/js/19.bcccd12c.js"><link rel="prefetch" href="/docs/assets/js/20.7842e092.js"><link rel="prefetch" href="/docs/assets/js/21.18769ae2.js"><link rel="prefetch" href="/docs/assets/js/22.08ec8cf7.js"><link rel="prefetch" href="/docs/assets/js/23.f899a7c4.js"><link rel="prefetch" href="/docs/assets/js/24.8e82b120.js"><link rel="prefetch" href="/docs/assets/js/25.a80e875c.js"><link rel="prefetch" href="/docs/assets/js/26.e4629eb9.js"><link rel="prefetch" href="/docs/assets/js/27.9d8604a8.js"><link rel="prefetch" href="/docs/assets/js/28.5144fdbe.js"><link rel="prefetch" href="/docs/assets/js/29.9db545a8.js"><link rel="prefetch" href="/docs/assets/js/3.7810185e.js"><link rel="prefetch" href="/docs/assets/js/31.af0a2225.js"><link rel="prefetch" href="/docs/assets/js/32.cd1745a2.js"><link rel="prefetch" href="/docs/assets/js/33.3cefacce.js"><link rel="prefetch" href="/docs/assets/js/34.37d8a377.js"><link rel="prefetch" href="/docs/assets/js/35.925dc186.js"><link rel="prefetch" href="/docs/assets/js/36.aae85628.js"><link rel="prefetch" href="/docs/assets/js/4.77a548c8.js"><link rel="prefetch" href="/docs/assets/js/5.5fd3c55b.js"><link rel="prefetch" href="/docs/assets/js/6.706caab8.js"><link rel="prefetch" href="/docs/assets/js/7.74938af9.js"><link rel="prefetch" href="/docs/assets/js/8.b788e12b.js"><link rel="prefetch" href="/docs/assets/js/9.c179b739.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.ec62b53c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><!----> <span class="site-name">行书子</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/xszi/javascript-algorithms" target="_blank" rel="noopener noreferrer" class="nav-link external">
  前端算法
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://xszi.github.io/docs/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  机器学习
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://xszi.github.io/docs" target="_blank" rel="noopener noreferrer" class="nav-link external">
  感悟杂记
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://www.github.com/xszi" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/xszi/javascript-algorithms" target="_blank" rel="noopener noreferrer" class="nav-link external">
  前端算法
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://xszi.github.io/docs/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  机器学习
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://xszi.github.io/docs" target="_blank" rel="noopener noreferrer" class="nav-link external">
  感悟杂记
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://www.github.com/xszi" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>前端译站</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/translation/category.html" class="sidebar-link">目录预览</a></li><li><a href="/docs/translation/nginx.html" class="sidebar-link">我希望我早点认识Nginx</a></li><li><a href="/docs/translation/callstack.html" class="sidebar-link">通过两个示例来解释递归和和调用堆栈</a></li><li><a href="/docs/translation/docker.html" class="sidebar-link">通过租用办公空间例子来解释Docker容器</a></li><li><a href="/docs/translation/nodeq.html" class="sidebar-link">关于Node.js的20个面试题</a></li><li><a href="/docs/translation/float.html" class="sidebar-link">将元素浮动到底角</a></li><li><a href="/docs/translation/eventloop.html" class="sidebar-link">可视化的JavaScript —— （一）事件循环</a></li><li><a href="/docs/translation/hoisting.html" class="sidebar-link">可视化的JavaScript —— （二）提升</a></li><li><a href="/docs/translation/scope.html" class="sidebar-link">可视化的JavaScript —— （三）作用域（链）</a></li><li><a href="/docs/translation/jsengine.html" class="sidebar-link">可视化的JavaScript —— （四）JS引擎</a></li><li><a href="/docs/translation/prototype.html" class="sidebar-link">可视化的JavaScript —— （五）原型继承</a></li><li><a href="/docs/translation/geniterator.html" class="sidebar-link">可视化的JavaScript —— （六）Generators 和 Iterators</a></li><li><a href="/docs/translation/promise.html" aria-current="page" class="active sidebar-link">可视化的JavaScript —— （七）Promises 和 Async/Await</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/docs/translation/stream.html" class="sidebar-link">NodeJS 流的可视化指南</a></li><li><a href="/docs/translation/chrometool.html" class="sidebar-link">使用 Chrome DevTools 高效调试 JavaScript</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>备忘</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/review/memo.html" class="sidebar-link">知识复习</a></li><li><a href="/docs/review/plan.html" class="sidebar-link">计划</a></li><li><a href="/docs/review/trend.html" class="sidebar-link">前端趋势</a></li><li><a href="/docs/review/question.html" class="sidebar-link">前端开发过程遇到的问题 / 建议</a></li><li><a href="/docs/review/html.html" class="sidebar-link">html备忘</a></li><li><a href="/docs/review/css.html" class="sidebar-link">css备忘</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>训练专题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/topic/sourcemap.html" class="sidebar-link">SourceMap</a></li><li><a href="/docs/topic/hmr.html" class="sidebar-link">HMR原理</a></li><li><a href="/docs/topic/algorithms.html" class="sidebar-link">算法</a></li><li><a href="/docs/topic/webpack.html" class="sidebar-link">webpack</a></li><li><a href="/docs/topic/monitor.html" class="sidebar-link">前端监控</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>TypeScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/typescript/intro.html" class="sidebar-link">安装 TypeScript</a></li><li><a href="/docs/typescript/install.html" class="sidebar-link">编写第一个 TypeScript 程序</a></li><li><a href="/docs/typescript/start.html" class="sidebar-link">初识 TypeScript</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="可视化的javascript-七-promises-和-async-await"><a href="#可视化的javascript-七-promises-和-async-await" class="header-anchor">#</a> 可视化的JavaScript —— （七）Promises 和 Async/Await</h1> <p>【七】<a href="https://dev.to/lydiahallie/javascript-visualized-promises-async-await-5gke" target="_blank" rel="noopener noreferrer">JavaScript Visualized: Promises &amp; Async/Await<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>是否曾经因为代码没有按照您预期的方式运行，而不得不对<strong>JS</strong> 代码进行处理 。函数似乎是在随机、不可预测的时间执行的，或者执行被延迟了。您可能正在使用 <strong>ES6</strong> 引入的一个很酷的新功能：<strong>Promises</strong>！</p> <p>我多年前的好奇心得到了答复，我的不眠之夜再次让我有时间制作一些动画。是时候讨论 <strong>Promise</strong> 了：你<strong>为什么</strong>要使用它们，它们<strong>如何</strong>在“幕后”工作，以及我们如何以最<strong>现代的</strong>方式实现它们？</p> <table><thead><tr><th>全文分为四个章节：</th></tr></thead> <tbody><tr><td>🥳 简介</td></tr> <tr><td>⚡️ Promise 语法</td></tr> <tr><td>♻️ 事件循环：微任务和（宏）任务</td></tr> <tr><td>🚀 异步/等待</td></tr></tbody></table> <h3 id="介绍"><a href="#介绍" class="header-anchor">#</a> 介绍</h3> <p>在编写 JavaScript 时，我们经常要处理依赖其他任务的任务！假设我们想要获取一个图像，压缩它，应用过滤器，然后保存它📸</p> <p>我们需要做的第一件事就是<em>获取</em>我们想要编辑的图像。一个<code>getImage</code>函数可以解决这个问题！只有成功加载该图像后，我们才能将该值传递给<code>resizeImage</code>函数。成功调整图像大小后，我们希望在<code>applyFilter</code>函数中对图像应用过滤器。压缩图像并添加过滤器后，我们要保存图像并让用户知道一切正常！🥳</p> <p>最后，我们会得到这样的结果：</p> <p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s---Kv6sJn7--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/ixceqsql5hpdq8txx43s.png" alt="img"></p> <p>嗯……注意到这里有什么吗？虽然它……<em>很好</em>，但不是很好。我们最终得到了许多依赖于前一个回调函数的嵌套回调函数。这通常被称为<a href="http://callbackhell.com/" target="_blank" rel="noopener noreferrer"><em>回调地狱</em><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，因为我们最终会得到大量嵌套的回调函数，这使得代码很难阅读！</p> <p>幸运的是，我们现在有了一个叫做**promises **的东西来帮助我们！让我们来看看 <strong>Promise</strong> 是什么，以及它们如何在这样的情况下帮助我们！😃</p> <h3 id="promise-语法"><a href="#promise-语法" class="header-anchor">#</a> Promise 语法</h3> <p>ES6 引入了<strong>Promise</strong>。在许多教程中，您将阅读以下内容：</p> <blockquote><p>“Promise是一个值的占位符，可以在未来的某个时间解决或拒绝”</p></blockquote> <p>是的...这个解释从来没有让我更清楚。事实上，它只是让我觉得 <strong>Promise</strong> 是一种奇怪的、模糊的、不可预测的魔法。因此，让我们看看都有哪些<strong>Promise</strong> 。</p> <p>我们可以创建一个<strong>Promise</strong> ，使用一个<code>Promise</code>接收回调的构造函数。好的，让我们试试吧！</p> <p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--phTVdCKA--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/79zi452hphe7ecylhozy.gif" alt="替换文字"></p> <p>等等，刚刚返回了什么？</p> <p>一个<code>Promise</code>是一个包含<strong>状态</strong>( <code>[[PromiseStatus]]</code>) 和<strong>值</strong>( <code>[[PromiseValue]]</code>) 的对象。在上面的例子中，你可以看到，值<code>[[PromiseStatus]]</code>的值是<code>&quot;pending&quot;</code>，<code>[[PromiseValue]]</code>的值是<code>undefined</code>。</p> <p>别担心 - 你永远不必与这个对象交互，你甚至不能访问<code>[[PromiseStatus]]</code>和<code>[[PromiseValue]]</code>属性！但是，在使用 <strong>Promise</strong> 时，这些属性的值很重要。</p> <p><code>PromiseStatus</code>的值，<strong>状态</strong>，可以是三个值之一：</p> <ul><li>✅ <code>fulfilled</code>：承诺已<code>resolved</code>。一切顺利，<strong>Promise</strong> 内没有出现错误🥳</li> <li>❌ <code>rejected</code>：<strong>Promise</strong> 已<code>rejected</code>。出事了..</li> <li>⏳ <code>pending</code>：<strong>promise</strong> 既没有解决也没有拒绝（还），<strong>promise</strong> 还是<code>pending</code>.</li></ul> <p>这一切听起来都很棒，但是什么时候 <strong>promise</strong> 状态是<code>&quot;pending&quot;</code>，<code>&quot;fulfilled&quot;</code>或<code>&quot;rejected&quot;</code>？为什么这种状态很重要？</p> <p>在上面的例子中，我们只是将简单的回调函数<code>() =&gt; {}</code>传递给<code>Promise</code>构造函数。然而，这个回调函数实际上接收两个参数。第一个参数的值，通常称为<code>resolve</code> 或者 <code>res</code>，是当 <code>Promise</code> <strong>resolve</strong>时要调用的方法。第二个参数的值，通常称为<code>reject</code>或者 <code>rej</code>，是当 <code>Promise</code> <strong>reject</strong>时要调用的值方法，此时出现了问题。</p> <p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--9A_mOYMP--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/duen4peq0bdr55cka5ya.png" alt="img"></p> <p>让我们试着看看当我们调用<code>resolve</code>或<code>reject</code>方法时会被记录下来！在我的示例中，我调用了<code>resolve</code>方法<code>res</code>和<code>reject</code>方法 <code>rej</code>。</p> <p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--qKIq-sYt--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/z0b9v0h7aiq073l5tl2l.gif" alt="img"></p> <p>我们终于知道如何摆脱<code>&quot;pending&quot;</code>状态和<code>undefined</code>值了！如果我们调用了<code>resolve</code>方法，<strong>promise</strong>的<strong>状态</strong>是<code>&quot;fulfilled&quot;</code>，如果我们调用了<code>rejecte</code>方法，<strong>promise</strong>的状态是<code>&quot;rejected</code>&quot;。</p> <p><strong>promise</strong>的值，<code>[[PromiseValue]]</code>，是我们作为参数传递给<code>resolved</code>或<code>rejected</code>方法的。</p> <blockquote><p>有趣的事实，我让 Jake Archibald 校对了这篇文章，他实际上指出 Chrome 中存在一个错误，当前显示状态为<code>&quot;resolved&quot;</code>而不是<code>&quot;fulfilled&quot;</code>。感谢<a href="https://twitter.com/mathias" target="_blank" rel="noopener noreferrer">Mathias Bynens，<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>它现在已在 Canary 中修复！🥳🕺🏼</p></blockquote> <p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--kZ3BKUHA--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://pbs.twimg.com/media/EVJqgKLUwAEocsG.png" alt="unknown tweet media content"></p> <p>好的，现在我们对如何控制那个模糊的<code>Promise</code>对象有了更好的了解。但是它有什么用呢？</p> <p>在介绍部分中，我展示了一个示例，其中我们获取图像、压缩它、应用文件管理器并保存它！最终，这最终成为一个嵌套的回调混乱。</p> <p>幸运的是，<strong>Promise</strong> 可以帮助我们解决这个问题！首先，让我们重写整个代码块，让每个函数返回一个<code>Promise</code>。</p> <p>如果图像已加载并且一切正常，我们用加载的图像解决<strong>Promise</strong> ！否则，如果加载文件时某处出现错误，我们<strong>拒绝</strong>发生错误的<strong>Promise</strong> 。</p> <p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--r9xngcNz--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/iebp0rzfnfqsrmmjplme.png" alt="img"></p> <p>让我们看看当我们在终端中运行它时会发生什么！</p> <p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--uERkfSWf--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/wsu5nn26dp4elcwh764m.gif" alt="img"></p> <p>正如我们预期的那样，一个带有解析数据值的<strong>Promise</strong> 被返回。</p> <p>但是……现在怎么办？我们不关心整个 <strong>Promise</strong> 对象，我们只关心数据的值！幸运的是，有一些内置方法可以获取 <strong>promise</strong> 的值。对于 promise，我们可以附加 3 个方法：</p> <ul><li><code>.then()</code>：在<strong>promise</strong> 解决后被调用。</li> <li><code>.catch()</code>：在<strong>promise</strong> 被拒绝*被调用。</li> <li><code>.finally()</code>：<em>总是</em>被调用，无论<strong>promise</strong> 已解决还是被拒绝。</li></ul> <p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--19tIvFJQ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/mu1aqqnyfjsfon5hwrtw.png" alt="img"></p> <p>该<code>.then</code>方法接收传递该<code>resolve</code>方法的值。</p> <p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--DZld0c-0--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/11vxhn9cun7stpjbdi80.gif" alt="img"></p> <p>该<code>.catch</code>方法接收传递<code>rejected</code>方法的值</p> <p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--e9SZHcPk--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/v5y24jz4u89flazvdyn4.gif" alt="img"></p> <p>最后，我们有了由 <strong>Promise</strong> 解析的值，而没有整个 <strong>Promise</strong> 对象！我们现在可以用这个值做任何我们想做的事情。</p> <p>当您知道<strong>Promise</strong> 将始终解决或始终拒绝时，您可以编写<code>Promise.resolve</code>或<code>Promise.reject</code>，使用您想要拒绝或解决<strong>Promise</strong> 的值！</p> <p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--61Gva3Ze--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/90hxwjfadzslvdbkr4l8.png" alt="Alt Text"></p> <p>你会经常在下面的例子中看到这种语法😄</p> <p>在<code>getImage</code>示例中，我们最终不得不嵌套多个回调以运行它们。幸运的是，<code>.then</code>处理程序可以帮助我们解决这个问题！🥳</p> <p><code>.then</code>本身的结果是一个<strong>Promise</strong> 值。这意味着我们可以根据需要链接任意数量的<code>.then</code>：前一个<code>then</code>回调的结果将作为参数传递给下一个<code>then</code>回调！</p> <p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--X8h-NDc2--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/i6busbetmoya9vny2eku.png" alt="img"></p> <p>在<code>getImage</code>示例的情况下，我们可以链接多个<code>then</code>回调，以便将处理后的图像传递给下一个函数！我们得到了一个干净的<code>then</code>链，而不是以许多嵌套的回调结束。</p> <p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--e1nVrqe1--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/u9l3lxwxlxgv2edv79xh.png" alt="img"></p> <p>这种语法看起来比嵌套回调更好。</p> <h3 id="微任务和-宏-任务"><a href="#微任务和-宏-任务" class="header-anchor">#</a> 微任务和（宏）任务</h3> <p>现在我们对如何创建<strong>Promise</strong> 以及如何从<strong>Promise</strong> 中提取值有了更好的了解。让我们向脚本添加更多代码，然后再次运行它：</p> <p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--uNG7sXon--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/ey4ubnv5yjgi6hbh97xq.gif" alt="img"></p> <p>等等，我们看发生了什么？</p> <p>首先，<code>Start!</code>登录。我们可以看到在第一行记录：<code>console.log('Start!')</code>！但是，记录的第二个值是<code>End!</code>，而<em>不是</em>已解决的<strong>Promise</strong> 的值！只有在<code>End!</code>被记录之后，<strong>Promise</strong> 的值才会被记录。这里发生了什么？</p> <p>我们终于看到了 <strong>Promise</strong> 的真正力量！🚀 虽然 JavaScript 是单线程的，但我们可以使用<code>Promise</code>添加异步行为。</p> <p>我们以前没见过吗？🤔 在<a href="https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif" target="_blank" rel="noopener noreferrer">JavaScript 事件循环中<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，我们不能也使用浏览器原生的方法<code>setTimeout</code>来创建某种异步行为吗？</p> <p>是的！然而，在事件循环中，实际上有两种类型的队列：（<strong>宏）任务队列</strong>（或简称为<strong>任务队列</strong>）和 <strong>微任务队列</strong>。<strong>（宏）任务队列</strong>  用于**（宏）任务**，<strong>微任务</strong>队列 用于 <strong>微任务</strong>。</p> <p>那么什么是**（宏）任务**，什么是<strong>微</strong>任务？虽然有一些文章比我在这里介绍的要多，但最常见的如下表所示！</p> <table><thead><tr><th>/</th> <th>举例</th></tr></thead> <tbody><tr><td>（宏）任务</td> <td><code>setTimeout</code>, <code>setInterval</code>,<code>setImmediate</code></td></tr> <tr><td>微任务</td> <td><code>process.nextTick</code>, <code>Promise callback</code>,<code>queueMicrotask</code></td></tr></tbody></table> <p>我们在微任务列表中看到<code>Promise</code>了！😃 当 一个<code>Promise</code>解析并调用它的<code>then()</code>, <code>catch()</code>或 <code>finally()</code> 方法时，该方法中的回调会被添加到<strong>微任务队列中</strong>！这意味着<code>then()</code>, <code>catch()</code>或<code>finally()</code>方法中的回调不会立即执行，实质上是向我们的 JavaScript 代码添加了一些异步行为！</p> <p>所以，什么时候<code>then()</code>，<code>catch()</code>或者<code>finally()</code>回调执行？事件循环为任务赋予不同的优先级：</p> <ol><li>当前在<strong>调用堆栈</strong>中的所有函数都被执行。当它们返回一个值时，它们会从堆栈中弹出。</li> <li>当调用栈为空时，<em>所有</em>排队的<strong>微任务</strong>都被一个一个的弹出到调用栈中，并被执行！（微任务本身也可以返回新的微任务，有效地创建了一个无限的微任务循环😬）</li> <li>如果调用堆栈和微任务队列都为空，则事件循环检查（宏）任务队列中是否还有任务。如果有，任务会被弹出到调用堆栈上，执行，然后弹出！</li></ol> <p>让我们看一个简单的例子，简单地使用：</p> <ul><li><code>Task1</code>：立即添加到调用堆栈的函数，例如通过在我们的代码中立即调用它。</li> <li><code>Task2</code>, <code>Task3</code>, <code>Task4</code>: 微任务，例如<code>Promise then</code>回调，或添加了<code>queueMicrotask</code>.</li> <li><code>Task5</code>, <code>Task6</code>: 一个（宏）任务，例如一个<code>setTimeout</code>或<code>setImmediate</code>回调</li></ul> <p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--05Fi8vBq--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/42eatw03fcha0e1qcrf0.gif" alt="img"></p> <p>首先，<code>Task1</code>返回一个值并从调用堆栈中弹出。然后，引擎检查在微任务队列中排队的任务。一旦所有任务都被放入调用堆栈并最终弹出，引擎就会检查（宏）任务队列中的任务，这些任务被弹出到调用堆栈中，并在它们返回值时弹出。</p> <p>让我们用一些真正的代码来使用它！</p> <p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--fnbqqf1d--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/g61wwyi8wchk2hpzeq4u.png" alt="img"></p> <p>在这段代码中，我们有宏任务<code>setTimeout</code>和微任务承诺<code>then()</code>回调。一旦引擎到达<code>setTimeout</code>功能。让我们一步一步地运行这段代码，看看记录了什么！</p> <blockquote><p>快速参考 - 在以下示例中，我将展示像<code>console.log</code>,<code>setTimeout</code>和<code>Promise.resolve</code>被添加到调用堆栈中的方法。它们是内部方法，实际上不会出现在堆栈跟踪中 - 所以如果您正在使用调试器并且在任何地方都看不到它们，请不要担心！它只是为了解释这个概念更容易而无需添加一堆样板代码🙂</p></blockquote> <p>在第一行，引擎遇到<code>console.log()</code>方法。它被添加到调用堆栈中，之后它将值记录<code>Start!</code>到控制台。该方法从调用堆栈中弹出，引擎继续。</p> <p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s---Bt6DKsn--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/6cbjuexvy6z9ltk0bi18.gif" alt="img"></p> <p>引擎遇到该<code>setTimeout</code>方法，该方法被弹出到调用堆栈中。该<code>setTimeout</code>方法是浏览器本机的：它的回调函数 ( <code>() =&gt; console.log('In timeout')</code>) 将被添加到 Web API，直到计时器完成。尽管我们<code>0</code>为计时器提供了值，但回调仍然首先被推送到 Web API，然后它被添加到**（宏）任务队列中**：<code>setTimeout</code>是一个宏任务！</p> <p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--6NSYq-nO--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/yqoemb6f32lvovge8yrp.gif" alt="img"></p> <p>引擎遇到<code>Promise.resolve()</code>方法。该<code>Promise.resolve()</code>方法被添加到调用堆栈中，之后使用 value 解析<code>Promise!</code>。它的<code>then</code>回调函数被添加到<strong>微任务队列中</strong>。</p> <p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--us8FF30N--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/6wxjxduh62fqt531e2rc.gif" alt="img"></p> <p>引擎遇到<code>console.log()</code>方法。它会立即添加到调用堆栈中，然后将值记录<code>End!</code>到控制台，从调用堆栈中弹出，然后引擎继续运行。</p> <p>引擎现在看到调用堆栈是空的。由于调用栈是空的，它会检查微任务<strong>队列中</strong>是否有排队的任务！是的，<code>Promise then</code>回调正在等待轮到它！它被弹出到调用堆栈中，之后它会记录<code>Promise</code>的解析值：<code>Promise</code>在这种情况下是字符串。</p> <p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--5iH5BNWm--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/lczn4fca41is4vpicr6w.gif" alt=""></p> <p>引擎看到调用堆栈是空的，因此它将再次检查微任务队列以查看任务是否已排队。不，微任务队列全是空的。</p> <p>是时候检查**（宏）任务队列了**：<code>setTimeout</code>回调仍在那里等待！该<code>setTimeout</code>回调被弹出到调用堆栈。回调函数返回<code>console.log</code>记录字符串的方法<code>&quot;In timeout!&quot;</code>。该<code>setTimeout</code>回调弹出调用堆栈。</p> <p>最后，一切都完成了！🥳 再来看我们之前看到的输出便不是那么出人意料了。</p> <h3 id="异步等待"><a href="#异步等待" class="header-anchor">#</a> 异步等待</h3> <p>ES7 引入了一种在 <strong>JavaScript</strong> 中添加异步行为的新方法，并使得使用 <strong>Promise</strong> 更容易！通过引入<code>async</code>和<code>await</code>关键字，我们可以创建隐式返回<strong>Promise</strong> 的<strong>异步</strong>函数。但是..我们怎么能做到这一点？😮</p> <p>此前，我们看到，我们可以明确地创建使用<code>Promise</code>的对象，无论是通过输入<code>new Promise(() =&gt; {})</code>，<code>Promise.resolve</code>或<code>Promise.reject</code>。</p> <p>我们现在可以创建<em>隐式</em>返回对象<code>Promise</code>的异步函数，而不是显式使用对象！这意味着我们不再需要自己编写任何<code>Promise</code>对象。</p> <p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--5ED_HyNC--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/72lqrcvy9lc8ehbpitd0.png" alt="img"></p> <p>尽管<strong>async</strong>函数隐式返回 <strong>promise</strong> 的事实非常棒，但<code>async</code>使用<code>await</code>关键字时可以看到函数的真正威力！使用<code>await</code>关键字，我们可以在等待ed 值返回已解决的承诺时<em>暂停</em>异步函数<code>await</code>。如果我们想获得这个已解析的 <strong>promise</strong> 的值，就像我们之前对<code>then()</code>回调所做的那样，我们可以将变量分配给<code>await</code>的 <strong>promise</strong> 值！</p> <p>那么，我们可以<em>挂起</em>一个异步函数吗？好吧，很好，但是……这到底是什么意思？</p> <p>让我们看看当我们运行以下代码块时会发生什么：</p> <p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--aOWmZxnV--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/e5duygomitj9o455107a.gif" alt="替换文字"></p> <p>这里发生了什么？</p> <p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--bfscMU3t--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/d27d7xxiekczftjyic4b.gif" alt="替换文字"></p> <p>首先，引擎遇到一个<code>console.log</code>. 它被弹出到调用堆栈中，然后<code>Before function!</code>被记录。</p> <p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--wN7yFTnt--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/9wqej2269vmntfcuxs9t.gif" alt="替换文字"></p> <p>然后，我们调用 async 函数<code>myFunc()</code>，然后<code>myFunc</code>运行函数体。在函数体的第一行，我们调用另一个<code>console.log</code>，这次是记录字符串 <code>In function!</code>。<code>console.log</code>将被添加到调用堆栈，记录该值，并得到弹出。</p> <p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--lX9JfreE--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/lch6lutxnl88j0durpyh.gif" alt="Alt Text"></p> <p>函数体继续执行，让我们进入第二行。最后，我们看到一个<code>await</code>关键字！🎉</p> <p>发生的第一件事是等待的值被执行：<code>one</code>在这种情况下是函数。它被弹出到调用堆栈上，并最终返回一个已解决的<strong>promise</strong> 。一旦<strong>promise</strong> 解决并返回一个值<code>one</code>，引擎就会遇到<code>await</code>关键字。</p> <p>遇到<code>await</code>关键字时，<code>async</code>函数会<em>暂停</em>。✋🏼 函数体的执行<strong>被暂停</strong>，其余的异步函数在<em>微</em>任务中运行，而不是在常规任务中运行！</p> <p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--UC78HoCO--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/b6l3psgewvtrtmrr60tg.gif" alt="替换文字"></p> <p>现在异步函数<code>myFunc</code>在遇到<code>await</code>关键字时被挂起，引擎跳出异步函数并继续在调用异步函数的执行上下文中执行代码：在这种情况下为<strong>全局执行上下文</strong>！🏃🏽‍♀️</p> <p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--V8u36kEG--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/hlhrtuspjyrstifubdhs.gif" alt="替换文字"></p> <p>最后，在全局执行上下文中没有更多的任务要运行了！事件循环检查是否有还有微任务排队：确实有！<code>async myFunc</code>函数<code>one</code>解析后的值在排队。<code>myFunc</code>被弹回调用堆栈，并在之前停止的地方继续运行。</p> <p>变量<code>res</code>最终得到了它的值，即<code>one</code>返回的已解析<strong>promise</strong>的值！在这种情况下，<code>console.log</code>记录<code>res</code>的字符串值<code>One!</code>。<code>One!</code>记录到控制台后并从调用堆栈中弹出！😊</p> <p>最后，一切都完成了！您是否注意到<code>async</code>函数与 <strong>promise</strong>的 <code>then</code>有何不同？该<code>await</code>关键字<em>暂停</em>的<code>async</code>功能，而<strong>promise</strong>会一直存在于我们已经使用过的<code>then</code>来准备执行！</p> <p>【完】</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">8/24/2022, 3:09:05 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/docs/translation/geniterator.html" class="prev">
        可视化的JavaScript —— （六）Generators 和 Iterators
      </a></span> <span class="next"><a href="/docs/translation/stream.html">
        NodeJS 流的可视化指南
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/docs/assets/js/app.3f2b36f9.js" defer></script><script src="/docs/assets/js/2.d55b7ed5.js" defer></script><script src="/docs/assets/js/30.0bff5648.js" defer></script>
  </body>
</html>
