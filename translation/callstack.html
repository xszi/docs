<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>通过两个示例来解释递归和和调用堆栈 | 行书子</title>
    <meta name="generator" content="VuePress 1.8.0">
    <link rel="icon" href="/docs/logo.png">
    <meta name="description" content="文档记录">
    
    <link rel="preload" href="/docs/assets/css/0.styles.ec62b53c.css" as="style"><link rel="preload" href="/docs/assets/js/app.2a9aebc7.js" as="script"><link rel="preload" href="/docs/assets/js/2.d55b7ed5.js" as="script"><link rel="preload" href="/docs/assets/js/19.bcccd12c.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.a4513dfc.js"><link rel="prefetch" href="/docs/assets/js/11.1ad8d137.js"><link rel="prefetch" href="/docs/assets/js/12.d85899e1.js"><link rel="prefetch" href="/docs/assets/js/13.a01e1e63.js"><link rel="prefetch" href="/docs/assets/js/14.1f1656b0.js"><link rel="prefetch" href="/docs/assets/js/15.a580ab76.js"><link rel="prefetch" href="/docs/assets/js/16.9c09fa24.js"><link rel="prefetch" href="/docs/assets/js/17.d6e1c557.js"><link rel="prefetch" href="/docs/assets/js/18.58c68ed2.js"><link rel="prefetch" href="/docs/assets/js/20.f0bedb87.js"><link rel="prefetch" href="/docs/assets/js/21.ca94759a.js"><link rel="prefetch" href="/docs/assets/js/22.2e40446d.js"><link rel="prefetch" href="/docs/assets/js/23.91a52ad1.js"><link rel="prefetch" href="/docs/assets/js/24.2fb9fbd7.js"><link rel="prefetch" href="/docs/assets/js/25.1d5a4e19.js"><link rel="prefetch" href="/docs/assets/js/26.7ef8fd92.js"><link rel="prefetch" href="/docs/assets/js/27.0e98421d.js"><link rel="prefetch" href="/docs/assets/js/28.32fec771.js"><link rel="prefetch" href="/docs/assets/js/29.a71db204.js"><link rel="prefetch" href="/docs/assets/js/3.ee451ee8.js"><link rel="prefetch" href="/docs/assets/js/30.d5838827.js"><link rel="prefetch" href="/docs/assets/js/31.d75b64c8.js"><link rel="prefetch" href="/docs/assets/js/32.b95775ff.js"><link rel="prefetch" href="/docs/assets/js/33.5e6e25fa.js"><link rel="prefetch" href="/docs/assets/js/34.5b01a07a.js"><link rel="prefetch" href="/docs/assets/js/35.d115cc5f.js"><link rel="prefetch" href="/docs/assets/js/4.77a548c8.js"><link rel="prefetch" href="/docs/assets/js/5.5fd3c55b.js"><link rel="prefetch" href="/docs/assets/js/6.706caab8.js"><link rel="prefetch" href="/docs/assets/js/7.74938af9.js"><link rel="prefetch" href="/docs/assets/js/8.b788e12b.js"><link rel="prefetch" href="/docs/assets/js/9.c179b739.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.ec62b53c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><!----> <span class="site-name">行书子</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/xszi/javascript-algorithms" target="_blank" rel="noopener noreferrer" class="nav-link external">
  前端算法
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://xszi.github.io/docs/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  机器学习
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://xszi.github.io/docs" target="_blank" rel="noopener noreferrer" class="nav-link external">
  感悟杂记
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://www.github.com/xszi" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/xszi/javascript-algorithms" target="_blank" rel="noopener noreferrer" class="nav-link external">
  前端算法
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://xszi.github.io/docs/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  机器学习
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://xszi.github.io/docs" target="_blank" rel="noopener noreferrer" class="nav-link external">
  感悟杂记
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://www.github.com/xszi" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>前端译站</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/translation/category.html" class="sidebar-link">目录预览</a></li><li><a href="/docs/translation/nginx.html" class="sidebar-link">我希望我早点认识Nginx</a></li><li><a href="/docs/translation/callstack.html" aria-current="page" class="active sidebar-link">通过两个示例来解释递归和和调用堆栈</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/docs/translation/docker.html" class="sidebar-link">通过租用办公空间例子来解释Docker容器</a></li><li><a href="/docs/translation/nodeq.html" class="sidebar-link">关于Node.js的20个面试题</a></li><li><a href="/docs/translation/float.html" class="sidebar-link">将元素浮动到底角</a></li><li><a href="/docs/translation/eventloop.html" class="sidebar-link">可视化的JavaScript —— （一）事件循环</a></li><li><a href="/docs/translation/hoisting.html" class="sidebar-link">可视化的JavaScript —— （二）提升</a></li><li><a href="/docs/translation/scope.html" class="sidebar-link">可视化的JavaScript —— （三）作用域（链）</a></li><li><a href="/docs/translation/jsengine.html" class="sidebar-link">可视化的JavaScript —— （四）JS引擎</a></li><li><a href="/docs/translation/prototype.html" class="sidebar-link">可视化的JavaScript —— （五）原型继承</a></li><li><a href="/docs/translation/geniterator.html" class="sidebar-link">可视化的JavaScript —— （六）Generators 和 Iterators</a></li><li><a href="/docs/translation/promise.html" class="sidebar-link">可视化的JavaScript —— （七）Promises 和 Async/Await</a></li><li><a href="/docs/translation/stream.html" class="sidebar-link">NodeJS 流的可视化指南</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>备忘</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/review/memo.html" class="sidebar-link">知识复习</a></li><li><a href="/docs/review/plan.html" class="sidebar-link">计划</a></li><li><a href="/docs/review/trend.html" class="sidebar-link">前端趋势</a></li><li><a href="/docs/review/question.html" class="sidebar-link">前端开发过程遇到的问题 / 建议</a></li><li><a href="/docs/review/html.html" class="sidebar-link">html备忘</a></li><li><a href="/docs/review/css.html" class="sidebar-link">css备忘</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>训练专题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/topic/sourcemap.html" class="sidebar-link">SourceMap</a></li><li><a href="/docs/topic/hmr.html" class="sidebar-link">HMR原理</a></li><li><a href="/docs/topic/algorithms.html" class="sidebar-link">算法</a></li><li><a href="/docs/topic/webpack.html" class="sidebar-link">webpack</a></li><li><a href="/docs/topic/monitor.html" class="sidebar-link">前端监控</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>TypeScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/typescript/intro.html" class="sidebar-link">安装 TypeScript</a></li><li><a href="/docs/typescript/install.html" class="sidebar-link">编写第一个 TypeScript 程序</a></li><li><a href="/docs/typescript/start.html" class="sidebar-link">初识 TypeScript</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="通过两个示例来解释递归和和调用堆栈"><a href="#通过两个示例来解释递归和和调用堆栈" class="header-anchor">#</a> 通过两个示例来解释递归和和调用堆栈</h1> <p><strong>文章出处</strong>：<a href="https://blog.codeanalogies.com/2020/01/14/recursion-and-the-call-stack-explained-by-reading-a-book/" target="_blank" rel="noopener noreferrer">Recursion and the Call Stack Explained By Reading A Book<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h3> <p><strong>递归</strong>是所有编程语言中最令人兴奋的原则之一。</p> <p>非递归函数（换句话说，您过去使用过的函数）将在每次调用时运行一次，并通过return语句输出。</p> <p>但是，递归函数可以被调用一次然后自身调用不确定次数，最后将所有函数调用的输出合并到一个return语句。</p> <p>下面是两种函数版本：</p> <ul><li>非递归
<img width="522" alt="aa" src="https://user-images.githubusercontent.com/23453305/113369804-c9803e80-9394-11eb-92a3-0874f20c6c6d.png"></li> <li>递归
<img width="523" alt="bb" src="https://user-images.githubusercontent.com/23453305/113368994-c08e6d80-9392-11eb-9548-4894c5625373.png"></li></ul> <p>通过单个语句可以将一个函数调用无穷次，Exciting！</p> <p>同时，从现实世界寻找这种情况的比喻是困难的。而且一旦讨论到调用栈，就更难了，我们将在后面讨论。</p> <p>有人提出了“无限盒子”：</p> <p><img src="https://user-images.githubusercontent.com/23453305/113369197-45798700-9393-11eb-8fde-2ec813426f4b.png" alt="image"></p> <p>还有“俄罗斯套娃”
<img src="https://user-images.githubusercontent.com/23453305/113369341-b9b42a80-9393-11eb-8391-8bd796fc4096.png" alt="image"></p> <p>但是，以上示例对于理解调用堆栈没什么帮助。</p> <p>所以，本文我们将展示两个流行的递归示例，并构建一种直观的语言来理解函数和调用堆栈，理解如何连续调用多个函数。</p> <p>在继续本文之前，您应该对<code>JavaScript</code>中的函数有了深入的了解。<a href="https://blog.codeanalogies.com/2019/04/14/javascripts-arrow-functions-explained-by-going-down-a-slide/" target="_blank" rel="noopener noreferrer">JavaScript’s Arrow Functions Explained By Going Down A Slide<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="示例1-阶乘"><a href="#示例1-阶乘" class="header-anchor">#</a> 示例1-阶乘</h3> <p><strong>阶乘</strong>是最流行的递归示例。</p> <p>您可能熟悉代数的阶乘。</p> <p>它们表示为：3！</p> <p>该符号的计算结果为3 * 2 * 1或6。</p> <p>我们可以将其表示为“ for”循环，在该循环外更新变量：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> factorial <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span>factorial<span class="token punctuation">;</span> i<span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    result <span class="token operator">=</span> result<span class="token operator">*</span>i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>我们再使用递归代替。可以使用递归和一个函数进行<code>n-1</code>个调用，而不是使用循环来更新循环外的变量，其中<code>n</code>是我们要查找的阶乘。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">getFactorial</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">else</span>
    <span class="token keyword">return</span> num <span class="token operator">*</span> <span class="token function">getFactorial</span><span class="token punctuation">(</span>num<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">getFactorial</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 24</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>哇！这完成了与上面的代码块相同的操作。</p> <p>但是，如果看一下第5行，您会发现<code>return</code>语句包含对函数本身的引用。</p> <p>那么……该函数何时准确返回最终值？我们如何将函数的4个调用链接在一起以返回<strong>24</strong>？</p> <p>这是调用堆栈有用的地方，它会确定这些函数调用返回的顺序。</p> <p>但是，现在我们一次堆叠了两个概念：递归和调用栈，太多了！</p> <p>为了可视化调用堆栈，我们考虑从左到右构建一个堆栈。每次添加一个块时，都会将其添加到堆栈的左侧，并将其他块推到右侧。</p> <p>因此，当我们执行此递归函数时，我们将生成如下所示的堆栈：</p> <p><img src="https://user-images.githubusercontent.com/23453305/113370768-4c09fd80-9397-11eb-8fa9-cb1723fab09c.gif" alt="recursionGIFsNum1"></p> <p>上面的GIF会在屏幕底部生成调用堆栈。最后剩下<strong>1 * 2 * 3 * 4</strong>，结果为24。</p> <p>调用堆栈由4个函数调用组成，并且直到函数返回1才运行。这是因为前三个调用中的每个都包含对堆栈中下一个调用的引用！</p> <p>当num = 4时，该函数返回4 * getFactorial（3）。在我们知道getFactorial（3）的值之前，它实际上无法返回值。这就是为什么我们需要一个调用堆栈！</p> <p>因此，递归允许连续调用一个函数无限次，并且它更新了调用堆栈，该堆栈在最终调用运行后返回一个值。</p> <p>调用堆栈从左到右更新，然后您可以按解决顺序读取所有调用。最先计算的是最近入栈，第一个入栈则最后计算。</p> <p>上面的GIF不能很好地显示每个调用之间的这种关系。因此，这是一个更新的版本，显示了如何通过return语句连接所有调用：</p> <p><img src="https://user-images.githubusercontent.com/23453305/113371279-8b851980-9398-11eb-91df-1a3c68e978a0.gif" alt="recursionGIFsfactorialnum2"></p> <h3 id="示例2-分割字符串"><a href="#示例2-分割字符串" class="header-anchor">#</a> 示例2-分割字符串</h3> <p>在上面的示例中，我们使用了一个数学示例，该数学示例类似于代数的问题。</p> <p>这行得通，但是还有许多递归示例，它们超出了数学范围。这个示例中，我们将展示如何使用递归来操作字符串。</p> <p>这是挑战：反转字符串。</p> <p>换句话说，以相反的顺序返回带有输入字符串字母的字符串。</p> <p>您也可以使用“ for”循环执行此操作，但是在此示例中，我们将使用递归。</p> <p>让我们考虑一下如何反转字符串“ cat”。</p> <p>每次运行函数调用时，我们都需要隔离字符串的第一个或最后一个字母，然后从字符串中切出一个字母。当我们再次运行该函数时，我们应该再次获取第一个或最后一个字母。</p> <p>最后，调用堆栈将使我们能够以正确的顺序返回字母。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> testStr <span class="token operator">=</span> <span class="token string">'cat'</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> <span class="token function-variable function">revStr</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">;</span>
  <span class="token keyword">else</span>
    <span class="token keyword">return</span> <span class="token function">revStr</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">revStr</span><span class="token punctuation">(</span>testStr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 'tac'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><img src="https://user-images.githubusercontent.com/23453305/113371574-46adb280-9399-11eb-866e-a105c51ef6a8.gif" alt="recursionex2v1"></p> <p>同样，尽管上面的GIF看起来很容易，但是如果我们想真正理解这些函数调用，就需要更深入地研究最终的return语句。</p> <p>与上面的示例相比，此示例还有一个重要的区别 —— <strong>我们在执行字符串连接而不是乘法</strong>。</p> <p>因此，该return语句中字符串的顺序相当重要，因为它确定我们将使用哪种顺序进行连接。</p> <p>由于这不是一系列乘法问题，因此调用栈更容易理解。这是一个视觉效果：</p> <p><img src="https://user-images.githubusercontent.com/23453305/113371701-93918900-9399-11eb-88a5-bdef4ca3eb2a.gif" alt="recursionex2"></p> <p>这就是字符串的顺序如此重要的原因-当我们在上面的GIF中构建调用堆栈时，递归函数调用和字符串片段（str [0]）有特定的顺序。</p> <p>当我们运行堆栈中的所有调用时，此顺序使我们能够以相反的顺序重建字符串。</p> <p>【完】</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">6/26/2021, 3:59:55 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/docs/translation/nginx.html" class="prev">
        我希望我早点认识Nginx
      </a></span> <span class="next"><a href="/docs/translation/docker.html">
        通过租用办公空间例子来解释Docker容器
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/docs/assets/js/app.2a9aebc7.js" defer></script><script src="/docs/assets/js/2.d55b7ed5.js" defer></script><script src="/docs/assets/js/19.bcccd12c.js" defer></script>
  </body>
</html>
